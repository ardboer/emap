#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

// Get project root directory
const projectRoot = process.cwd();

/**
 * Enhanced pre-build script for multi-brand builds
 * Uses generic package structure to avoid cache clearing between brand switches
 *
 * Usage: node scripts/prebuild.js <brand>
 * Example: node scripts/prebuild.js cn
 */

const brand = process.argv[2];

if (!brand) {
  console.error("âŒ Brand parameter is required");
  console.error("Usage: node scripts/prebuild.js <brand>");
  process.exit(1);
}

console.log(`ğŸš€ Starting pre-build process for brand: ${brand}`);

// Validate brand
const validBrands = ["cn", "nt"];
if (!validBrands.includes(brand)) {
  console.error(`âŒ Invalid brand: ${brand}`);
  console.error(`Valid brands: ${validBrands.join(", ")}`);
  process.exit(1);
}

// Load brand configuration
const brandConfigPath = path.join(projectRoot, "brands", brand, "config.json");
if (!fs.existsSync(brandConfigPath)) {
  console.error(`âŒ Brand configuration not found: ${brandConfigPath}`);
  process.exit(1);
}

const brandConfig = JSON.parse(fs.readFileSync(brandConfigPath, "utf8"));
console.log(`âœ… Loaded brand configuration for: ${brandConfig.displayName}`);

// Load environment variables from brand-specific .env file
const envPath = path.join(projectRoot, `.env.${brand}`);
if (fs.existsSync(envPath)) {
  const envContent = fs.readFileSync(envPath, "utf8");
  console.log(`âœ… Loaded environment variables from: .env.${brand}`);

  // Parse and set environment variables
  envContent.split("\n").forEach((line) => {
    const trimmedLine = line.trim();
    if (trimmedLine && !trimmedLine.startsWith("#")) {
      const [key, ...valueParts] = trimmedLine.split("=");
      if (key && valueParts.length > 0) {
        process.env[key] = valueParts.join("=");
      }
    }
  });
}

// Update app.json with brand-specific configuration
const appJsonPath = path.join(projectRoot, "app.json");
const appJson = JSON.parse(fs.readFileSync(appJsonPath, "utf8"));

// Update app configuration
appJson.expo.name = brandConfig.displayName;
// Keep slug as "emap" for EAS project consistency
// appJson.expo.slug = `emap-${brand}`;

// Update bundle identifiers
const bundleId =
  brand === "cn"
    ? "metropolis.co.uk.constructionnews"
    : "metropolis.net.nursingtimes";

// Use generic bundle identifier for iOS project structure (avoids pod rebuilds)
const genericIOSBundleId = "com.emap.app";

// Set generic iOS bundle identifier for project structure
appJson.expo.ios.bundleIdentifier = genericIOSBundleId;
appJson.expo.android.package = bundleId;

// Use generic package structure for Android source files
const genericPackageId = "com.emap.app";

// Store the actual brand-specific bundle ID for iOS build configuration
appJson.expo.extra.brandConfig.actualIOSBundleId = bundleId;

// Update assets paths to use brand-specific assets
const brandAssetsPath = `./brands/${brand}/assets`;
appJson.expo.icon = `${brandAssetsPath}/icon.png`;
appJson.expo.android.adaptiveIcon.foregroundImage = `${brandAssetsPath}/adaptive-icon.png`;
appJson.expo.web.favicon = `${brandAssetsPath}/favicon.png`;

// Update splash screen
if (appJson.expo.plugins) {
  appJson.expo.plugins.forEach((plugin) => {
    if (Array.isArray(plugin) && plugin[0] === "expo-splash-screen") {
      plugin[1].image = `${brandAssetsPath}/splash-icon.png`;
    }
  });
}

// Add brand-specific extra configuration
appJson.expo.extra.brandConfig = {
  ...appJson.expo.extra.brandConfig,
  brand: brand,
  brandName: brandConfig.displayName,
  bundleIdentifier: bundleId,
};

// Write updated app.json
fs.writeFileSync(appJsonPath, JSON.stringify(appJson, null, 2));
console.log(
  `âœ… Updated app.json with ${brandConfig.displayName} configuration`
);

// Copy brand-specific assets to main assets directory
const copyAssets = () => {
  const brandAssetsDir = path.join(projectRoot, "brands", brand, "assets");
  const mainAssetsDir = path.join(projectRoot, "assets", "images");

  if (!fs.existsSync(brandAssetsDir)) {
    console.warn(`âš ï¸  Brand assets directory not found: ${brandAssetsDir}`);
    return;
  }

  const assetFiles = [
    "icon.png",
    "adaptive-icon.png",
    "favicon.png",
    "splash-icon.png",
    "react-logo.png",
    "react-logo@2x.png",
    "react-logo@3x.png",
    "partial-react-logo.png",
  ];

  assetFiles.forEach((file) => {
    const sourcePath = path.join(brandAssetsDir, file);
    const destPath = path.join(mainAssetsDir, file);

    if (fs.existsSync(sourcePath)) {
      fs.copyFileSync(sourcePath, destPath);
      console.log(`âœ… Copied ${file} to main assets`);
    } else {
      console.warn(`âš ï¸  Asset file not found: ${sourcePath}`);
    }
  });
};

copyAssets();

// Generate brand key file
const generateBrandKeyFile = () => {
  const brandKeyPath = path.join(projectRoot, "config", "brandKey.ts");
  const brandKeyContent = `// This file is auto-generated by the prebuild script
// Do not edit manually - it will be overwritten

export const ACTIVE_BRAND = '${brand}';
`;

  fs.writeFileSync(brandKeyPath, brandKeyContent);
  console.log(`âœ… Generated brand key file with brand: ${brand}`);
};

generateBrandKeyFile();

// Update Android keystore alias based on brand
const updateKeystoreAlias = () => {
  const gradlePropertiesPath = path.join(
    projectRoot,
    "android",
    "gradle.properties"
  );

  if (!fs.existsSync(gradlePropertiesPath)) {
    console.warn(`âš ï¸  gradle.properties not found: ${gradlePropertiesPath}`);
    return;
  }

  let gradleContent = fs.readFileSync(gradlePropertiesPath, "utf8");

  // Determine the correct key alias based on brand
  const keyAlias =
    brand === "cn" ? "construction-news-key" : "nursing-times-key";

  // Update the key alias in gradle.properties
  gradleContent = gradleContent.replace(
    /MYAPP_RELEASE_KEY_ALIAS=.*/,
    `MYAPP_RELEASE_KEY_ALIAS=${keyAlias}`
  );

  fs.writeFileSync(gradlePropertiesPath, gradleContent);
  console.log(`âœ… Updated keystore alias to: ${keyAlias}`);
};

updateKeystoreAlias();

// Update Android build.gradle with correct package name
const updateAndroidBuildGradle = () => {
  const buildGradlePath = path.join(
    projectRoot,
    "android",
    "app",
    "build.gradle"
  );

  if (!fs.existsSync(buildGradlePath)) {
    console.warn(`âš ï¸  build.gradle not found: ${buildGradlePath}`);
    return;
  }

  let buildGradleContent = fs.readFileSync(buildGradlePath, "utf8");

  // Update namespace to use generic package (stays consistent)
  buildGradleContent = buildGradleContent.replace(
    /namespace\s+['"][^'"]*['"]/,
    `namespace '${genericPackageId}'`
  );

  // Update applicationId with the brand-specific bundle identifier
  buildGradleContent = buildGradleContent.replace(
    /applicationId\s+['"][^'"]*['"]/,
    `applicationId '${bundleId}'`
  );

  fs.writeFileSync(buildGradlePath, buildGradleContent);
  console.log(`âœ… Updated Android build.gradle:`);
  console.log(`   - namespace: ${genericPackageId} (generic)`);
  console.log(`   - applicationId: ${bundleId} (brand-specific)`);
};

updateAndroidBuildGradle();

// Setup generic Android source structure (one-time migration)
const setupGenericAndroidStructure = () => {
  const androidSrcPath = path.join(
    projectRoot,
    "android",
    "app",
    "src",
    "main",
    "java"
  );

  const genericPackagePath = path.join(androidSrcPath, "com", "emap", "app");

  // Check if generic structure already exists
  if (fs.existsSync(genericPackagePath)) {
    console.log(
      `âœ… Generic package structure already exists: ${genericPackageId}`
    );
    return;
  }

  // Find existing brand-specific package directories
  const possibleOldPaths = [
    {
      path: path.join(androidSrcPath, "metropolis", "net", "nursingtimes"),
      packageId: "metropolis.net.nursingtimes",
    },
    {
      path: path.join(
        androidSrcPath,
        "metropolis",
        "co",
        "uk",
        "constructionnews"
      ),
      packageId: "metropolis.co.uk.constructionnews",
    },
  ];

  let sourcePackageInfo = null;
  for (const possibleOld of possibleOldPaths) {
    if (fs.existsSync(possibleOld.path)) {
      sourcePackageInfo = possibleOld;
      break;
    }
  }

  if (!sourcePackageInfo) {
    console.log(
      `â„¹ï¸  No existing package structure found, creating generic structure`
    );
    fs.mkdirSync(genericPackagePath, { recursive: true });
    return;
  }

  // Create generic package directory
  fs.mkdirSync(genericPackagePath, { recursive: true });

  // Move Kotlin files to generic package directory
  const kotlinFiles = ["MainActivity.kt", "MainApplication.kt"];
  kotlinFiles.forEach((file) => {
    const oldFilePath = path.join(sourcePackageInfo.path, file);
    const newFilePath = path.join(genericPackagePath, file);

    if (fs.existsSync(oldFilePath)) {
      // Read file content and update package declaration to generic
      let fileContent = fs.readFileSync(oldFilePath, "utf8");

      // Replace old package declaration with generic one
      const oldPackageRegex = new RegExp(
        `package\\s+${sourcePackageInfo.packageId.replace(/\./g, "\\.")}`
      );
      fileContent = fileContent.replace(
        oldPackageRegex,
        `package ${genericPackageId}`
      );

      // Write to new generic location
      fs.writeFileSync(newFilePath, fileContent);
      console.log(
        `âœ… Migrated ${file} from ${sourcePackageInfo.packageId} to ${genericPackageId}`
      );

      // Remove old file
      fs.unlinkSync(oldFilePath);
    }
  });

  // Clean up old directory structure
  try {
    fs.rmdirSync(sourcePackageInfo.path);

    // Clean up parent directories if empty
    const pathParts = sourcePackageInfo.path
      .replace(androidSrcPath + path.sep, "")
      .split(path.sep);
    for (let i = pathParts.length - 1; i > 0; i--) {
      const parentPath = path.join(androidSrcPath, ...pathParts.slice(0, i));
      try {
        fs.rmdirSync(parentPath);
      } catch (error) {
        break; // Directory not empty
      }
    }

    console.log(`âœ… Cleaned up old brand-specific package structure`);
  } catch (error) {
    // Directory not empty or doesn't exist, ignore
  }
};

setupGenericAndroidStructure();

// Setup generic iOS structure (when iOS project exists)
const setupGenericIOSStructure = () => {
  const iosProjectPath = path.join(projectRoot, "ios");

  if (!fs.existsSync(iosProjectPath)) {
    console.log(
      `â„¹ï¸  iOS project not found - will use generic structure when generated`
    );
    return;
  }

  // Look for existing Xcode project files
  const projectFiles = fs
    .readdirSync(iosProjectPath)
    .filter((file) => file.endsWith(".xcodeproj"));

  if (projectFiles.length === 0) {
    console.log(`â„¹ï¸  No Xcode project found in iOS directory`);
    return;
  }

  // Check if we need to rename the project to generic name
  const currentProjectName = projectFiles[0].replace(".xcodeproj", "");
  const genericProjectName = "emap";

  if (currentProjectName === genericProjectName) {
    console.log(
      `âœ… iOS project already uses generic name: ${genericProjectName}`
    );
    return;
  }

  console.log(`ğŸ”„ Converting iOS project to generic structure...`);
  console.log(`   From: ${currentProjectName} â†’ To: ${genericProjectName}`);

  // This would require renaming Xcode project files and updating references
  // For now, we'll log the recommendation
  console.log(`â„¹ï¸  To complete iOS generic setup:`);
  console.log(
    `   1. Rename ${currentProjectName}.xcodeproj to ${genericProjectName}.xcodeproj`
  );
  console.log(
    `   2. Update bundle identifier in Xcode to: ${genericIOSBundleId}`
  );
  console.log(
    `   3. Use EAS build configuration to set final bundle ID at build time`
  );
};

setupGenericIOSStructure();

console.log(
  `\nğŸ‰ Pre-build process completed successfully for ${brandConfig.displayName}`
);
console.log(`ğŸ“± Android Bundle ID: ${bundleId}`);
console.log(
  `ğŸ“± iOS Bundle ID: ${genericIOSBundleId} â†’ ${bundleId} (at build time)`
);
console.log(`ğŸ¨ Brand: ${brand}`);
console.log(`ğŸ“ Generic Android Package: ${genericPackageId}`);
console.log(`ğŸ“ Generic iOS Bundle: ${genericIOSBundleId}`);
console.log(`\nğŸ’¡ Benefits of generic structure:`);
console.log(`   â€¢ No cache clearing needed when switching brands`);
console.log(`   â€¢ No pod rebuilds required for iOS`);
console.log(`   â€¢ Faster brand switching`);
console.log(`   â€¢ Consistent build artifacts`);
console.log(`\nğŸš€ Next steps:`);
console.log(`   1. Configure: node scripts/prebuild.js ${brand}`);
console.log(`   2. Android: cd android && ./gradlew bundleRelease`);
console.log(`   3. iOS: Use EAS build or Xcode with generic project`);
